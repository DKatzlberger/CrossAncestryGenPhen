#' Permutation-Based Aggregation Test for Features (Per-Feature Inference)
#'
#' Performs permutation testing for per-feature aggregated statistics across resampling iterations.
#' For each feature (e.g., gene), the function aggregates test statistics using a specified function
#' (e.g., mean), and compares the observed value to a null distribution generated by permutation.
#'
#' @param x A data.frame or data.table with test statistics and feature assignments.
#' @param T_col Character. Name of the column in \code{x} containing the test statistic.
#' @param feature_col Character. Name of the column in \code{x} identifying features (e.g., gene IDs).
#' @param agg_fun Function to aggregate statistics per feature (default: \code{mean}).
#' @param alternative Character. One of \code{"two.sided"}, \code{"greater"}, or \code{"less"}.
#' @param alpha Numeric. FDR threshold to compute the overall proportion of significant features (default: 0.05).
#' @param B Integer. Number of permutations (default: 1000).
#' @param seed Integer or NULL. Random seed for reproducibility.
#'
#' @return A list with:
#' \describe{
#'   \item{summary_stats}{A data.frame with per-feature results: observed statistic, empirical p-value, FDR-adjusted p-value, and test direction.}
#'   \item{T_perm}{Matrix of permutation-based aggregated statistics (rows = permutations, columns = features).}
#'   \item{prop_sig}{The proportion of features with FDR-adjusted p-values below \code{alpha}.}
#' }
#'
#' @export
perm_aggregate_sets <- function(
  x,
  T_col,
  feature_col,
  agg_fun = mean,
  alternative = c("two.sided", "greater", "less"),
  B = 1000,
  alpha = 0.05,
  seed = NULL
) {

  if (!is.null(seed)) set.seed(seed)

  features <- unique(x[[feature_col]])
  n_features <- length(features)

  # Observed statistic per feature
  obs_vec <- tapply(x[[T_col]], x[[feature_col]], FUN = agg_fun)

  # Permutation matrix: rows = permutations, columns = features
  perm_matrix <- matrix(NA_real_, nrow = B, ncol = n_features)
  colnames(perm_matrix) <- names(obs_vec)

  for (f in seq_along(features)) {
    # Permutation
    T_f <- x[x[[feature_col]] == features[f], T_col]
    perm_matrix[, f] <- replicate(B, agg_fun(sample(T_f)))
  }

  # Empirical p-values
  p_value <- numeric(n_features)
  for (f in seq_along(features)) {
    p_value[f] <- compute_empirical_p(
      T_obs = obs_vec[f],
      T_null = perm_matrix[, f],
      alternative = alternative
    )
  }

  # Adjust for multiple testing
  p_adj <- p.adjust(p_value, method = "BH")

  # Compute per-feature proportion of significant iterations (from input p_adj column)
  prop_sig <- tapply(x$p_adj < alpha, x[[feature_col]], mean, na.rm = TRUE)

  # Assemble result
  result <- list(
    summary_stats = data.frame(
      feature = names(obs_vec),
      T_obs = obs_vec,
      p_value = p_value,
      p_adj = p_adj,
      prop_sig = prop_sig[names(obs_vec)],
      alternative = alternative,
      row.names = NULL
    ),
    T_perm = perm_matrix  
  )

  return(result)
}
